// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/lightclients/lcp/v1/lcp.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/cosmos/ibc-go/v8/modules/core/02-client/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// A message containing information required to update the client.
type UpdateClientMessage struct {
	// A proxy message generated by the LCP node running on the target platform
	ProxyMessage []byte `protobuf:"bytes,1,opt,name=proxy_message,json=proxyMessage,proto3" json:"proxy_message,omitempty"`
	// Signatures of the proxy message by the LCP node
	Signatures [][]byte `protobuf:"bytes,2,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *UpdateClientMessage) Reset()         { *m = UpdateClientMessage{} }
func (m *UpdateClientMessage) String() string { return proto.CompactTextString(m) }
func (*UpdateClientMessage) ProtoMessage()    {}
func (*UpdateClientMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_69f4c398e914fe8d, []int{0}
}
func (m *UpdateClientMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateClientMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateClientMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateClientMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateClientMessage.Merge(m, src)
}
func (m *UpdateClientMessage) XXX_Size() int {
	return m.Size()
}
func (m *UpdateClientMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateClientMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateClientMessage proto.InternalMessageInfo

// A message to verify IAS report and signature for the enclave key registration
type RegisterEnclaveKeyMessage struct {
	// IAS report
	Report []byte `protobuf:"bytes,1,opt,name=report,proto3" json:"report,omitempty"`
	// A signature of the IAS report by the IAS signing key
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// A certificate of the IAS signing key
	SigningCert []byte `protobuf:"bytes,3,opt,name=signing_cert,json=signingCert,proto3" json:"signing_cert,omitempty"`
	// An operator's signature of the EIP-712 message `RegisterEnclaveKey`
	OperatorSignature []byte `protobuf:"bytes,4,opt,name=operator_signature,json=operatorSignature,proto3" json:"operator_signature,omitempty"`
}

func (m *RegisterEnclaveKeyMessage) Reset()         { *m = RegisterEnclaveKeyMessage{} }
func (m *RegisterEnclaveKeyMessage) String() string { return proto.CompactTextString(m) }
func (*RegisterEnclaveKeyMessage) ProtoMessage()    {}
func (*RegisterEnclaveKeyMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_69f4c398e914fe8d, []int{1}
}
func (m *RegisterEnclaveKeyMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterEnclaveKeyMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterEnclaveKeyMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterEnclaveKeyMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterEnclaveKeyMessage.Merge(m, src)
}
func (m *RegisterEnclaveKeyMessage) XXX_Size() int {
	return m.Size()
}
func (m *RegisterEnclaveKeyMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterEnclaveKeyMessage.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterEnclaveKeyMessage proto.InternalMessageInfo

// A message to verify zkDCAP's output and proof for the enclave key registration
type ZKDCAPRegisterEnclaveKeyMessage struct {
	// A type of zkVM generated the `quote_verification_output` and `proof`
	ZkvmType uint32 `protobuf:"varint,1,opt,name=zkvm_type,json=zkvmType,proto3" json:"zkvm_type,omitempty"`
	// An output of the zkDCAP program that verifies the quote
	QuoteVerificationOutput []byte `protobuf:"bytes,2,opt,name=quote_verification_output,json=quoteVerificationOutput,proto3" json:"quote_verification_output,omitempty"`
	// A proof of the zkVM generated the `quote_verification_output`
	Proof []byte `protobuf:"bytes,3,opt,name=proof,proto3" json:"proof,omitempty"`
	// An operator's signature of the EIP-712 message `ZKDCAPRegisterEnclaveKey`
	OperatorSignature []byte `protobuf:"bytes,4,opt,name=operator_signature,json=operatorSignature,proto3" json:"operator_signature,omitempty"`
}

func (m *ZKDCAPRegisterEnclaveKeyMessage) Reset()         { *m = ZKDCAPRegisterEnclaveKeyMessage{} }
func (m *ZKDCAPRegisterEnclaveKeyMessage) String() string { return proto.CompactTextString(m) }
func (*ZKDCAPRegisterEnclaveKeyMessage) ProtoMessage()    {}
func (*ZKDCAPRegisterEnclaveKeyMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_69f4c398e914fe8d, []int{2}
}
func (m *ZKDCAPRegisterEnclaveKeyMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKDCAPRegisterEnclaveKeyMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKDCAPRegisterEnclaveKeyMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKDCAPRegisterEnclaveKeyMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKDCAPRegisterEnclaveKeyMessage.Merge(m, src)
}
func (m *ZKDCAPRegisterEnclaveKeyMessage) XXX_Size() int {
	return m.Size()
}
func (m *ZKDCAPRegisterEnclaveKeyMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKDCAPRegisterEnclaveKeyMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ZKDCAPRegisterEnclaveKeyMessage proto.InternalMessageInfo

type UpdateOperatorsMessage struct {
	// A nonce for this operators update
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// A list of new operators
	NewOperators [][]byte `protobuf:"bytes,2,rep,name=new_operators,json=newOperators,proto3" json:"new_operators,omitempty"`
	// A numerator of the threshold of signatures required for new operators
	NewOperatorsThresholdNumerator uint64 `protobuf:"varint,3,opt,name=new_operators_threshold_numerator,json=newOperatorsThresholdNumerator,proto3" json:"new_operators_threshold_numerator,omitempty"`
	// A denominator of the threshold of signatures required for new operators
	NewOperatorsThresholdDenominator uint64 `protobuf:"varint,4,opt,name=new_operators_threshold_denominator,json=newOperatorsThresholdDenominator,proto3" json:"new_operators_threshold_denominator,omitempty"`
	// Signatures of the EIP-712 message `UpdateOperators` by the current operators
	Signatures [][]byte `protobuf:"bytes,5,rep,name=signatures,proto3" json:"signatures,omitempty"`
}

func (m *UpdateOperatorsMessage) Reset()         { *m = UpdateOperatorsMessage{} }
func (m *UpdateOperatorsMessage) String() string { return proto.CompactTextString(m) }
func (*UpdateOperatorsMessage) ProtoMessage()    {}
func (*UpdateOperatorsMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_69f4c398e914fe8d, []int{3}
}
func (m *UpdateOperatorsMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateOperatorsMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateOperatorsMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateOperatorsMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateOperatorsMessage.Merge(m, src)
}
func (m *UpdateOperatorsMessage) XXX_Size() int {
	return m.Size()
}
func (m *UpdateOperatorsMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateOperatorsMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateOperatorsMessage proto.InternalMessageInfo

type ClientState struct {
	// This value strictly identifies the allowed enclave.
	Mrenclave []byte `protobuf:"bytes,1,opt,name=mrenclave,proto3" json:"mrenclave,omitempty"`
	// The `key_expiration` is used to determine the validity period of the EK.
	//
	// The logic for calculating EK validity periods slightly differs between IAS and DCAP:
	//
	// IAS:
	// - This value must be greater than 0.
	// - The EK validity ends at `ias_report.timestamp + key_expiration`.
	//
	// DCAP:
	// - If the value is 0, the EK validity ends at `output.validity.not_after`.
	// - If the value is greater than 0, the EK validity ends at:
	//   min(`qv_output.validity.not_before` + key_expiration, `output.validity.not_after`)
	//
	// Considerations:
	// - Operators should fetch the latest collateral from Intel Provisioning Certification Service (PCS) to ensure the EK validity starts close to the current time.
	// - When the EK expires and the TCB evaluation data number has been updated, operators might not be immediately ready
	//   to operate with the newly accepted TCB status, resulting in availability risks.
	//   To mitigate this risk, operators should set an appropriate `tcb_evaluation_data_number_update_grace_period`.
	KeyExpiration uint64 `protobuf:"varint,2,opt,name=key_expiration,json=keyExpiration,proto3" json:"key_expiration,omitempty"`
	// Indicates whether the client is frozen.
	Frozen bool `protobuf:"varint,3,opt,name=frozen,proto3" json:"frozen,omitempty"`
	// The height of the latest consensus state that the client has tracked
	LatestHeight types.Height `protobuf:"bytes,4,opt,name=latest_height,json=latestHeight,proto3" json:"latest_height"`
	// Determines which SGX enclave quote statuses are acceptable.
	//
	// Operators must configure this carefully based on their operational
	// security posture and environment-specific considerations.
	//
	// e.g. IAS: SW_HARDENING_NEEDED, CONFIGURATION_AND_SW_HARDENING_NEEDED
	//      DCAP: SWHardeningNeeded, ConfigurationAndSWHardeningNeeded
	AllowedQuoteStatuses []string `protobuf:"bytes,5,rep,name=allowed_quote_statuses,json=allowedQuoteStatuses,proto3" json:"allowed_quote_statuses,omitempty"`
	// Specifies Security Advisory IDs that operators explicitly allow.
	//
	// Operators must carefully consider the security implications of allowing specific advisories.
	//
	// e.g. INTEL-SA-00001, INTEL-SA-00002
	AllowedAdvisoryIds []string `protobuf:"bytes,6,rep,name=allowed_advisory_ids,json=allowedAdvisoryIds,proto3" json:"allowed_advisory_ids,omitempty"`
	// A list of LCP operator addresses (ethereum format) associated with this client.
	//
	// If this field is empty, operator signatures are not required, allowing any entity to act as an operator.
	//
	// Operational assumptions:
	// - At least one operator (including entities not listed in the `operators` field) is expected to promptly reference and report the latest TCB evaluation data number.
	//   - If no operator promptly reports the latest TCB number, the client continues accepting attestations based on outdated collateral for up to 12 months.
	// - Not all operators may immediately prepare an SGX environment compatible with the latest TCB level.
	//   - The `tcb_evaluation_data_number_update_grace_period` ensures that all operators have a guaranteed minimum period to update their SGX environments, maintaining overall availability.
	Operators [][]byte `protobuf:"bytes,7,rep,name=operators,proto3" json:"operators,omitempty"`
	// The current nonce used in operator updates.
	OperatorsNonce uint64 `protobuf:"varint,8,opt,name=operators_nonce,json=operatorsNonce,proto3" json:"operators_nonce,omitempty"`
	// The numerator of the signature threshold for operator updates.
	OperatorsThresholdNumerator uint64 `protobuf:"varint,9,opt,name=operators_threshold_numerator,json=operatorsThresholdNumerator,proto3" json:"operators_threshold_numerator,omitempty"`
	// The denominator of the signature threshold for operator updates.
	OperatorsThresholdDenominator uint64 `protobuf:"varint,10,opt,name=operators_threshold_denominator,json=operatorsThresholdDenominator,proto3" json:"operators_threshold_denominator,omitempty"`
	// The current TCB evaluation data number
	//
	// The client only accepts the zkDCAP output generated using collateral with a TCB evaluation data number equal to or greater than this number.
	CurrentTcbEvaluationDataNumber uint32 `protobuf:"varint,11,opt,name=current_tcb_evaluation_data_number,json=currentTcbEvaluationDataNumber,proto3" json:"current_tcb_evaluation_data_number,omitempty"`
	// The grace period (in seconds) for operators to update their SGX environments to support a newly observed TCB evaluation data number.
	//
	// Notes:
	// - A shorter grace period could increase availability risk if operators are not given sufficient time
	//   to prepare the new SGX environment compatible with the updated TCB level.
	// - Conversely, a longer grace period could delay the adoption of the latest TCB level, potentially increasing security risks.
	// - Operators must carefully consider their operational preparation needs and security posture when configuring this value.
	//
	// When a new TCB evaluation data number greater than the current number is observed:
	//
	// - If the grace period is zero:
	//   - The current number is updated immediately.
	//
	// - If the grace period is non-zero:
	//   - The new number is reserved as `next_tcb_evaluation_data_number`.
	//   - `next_tcb_evaluation_data_number_update_time` is set to current timestamp plus the grace period.
	//
	// Edge cases:
	//
	//   - Edge case 1 (current < next < newly observed number):
	//     - Immediate activation of reserved next number, bypassing the remaining grace period.
	//     - Newly observed number is reserved as the next number.
	//
	//   - Edge case 2 (current < newly observed number < next):
	//     - Immediate activation of newly observed number, preserving the reserved next number.
	//
	// These edge cases can occur due to excessively long grace periods or frequent TCB Recovery Events occurring within shorter intervals than the typical 6-month update frequency.
	// Note that we assume operators can maintain an appropriate TCB status based on previous TCB collateral. Therefore, we expect that immediate updates in these edge cases do not cause operational issues.
	// Additionally, with a well-configured grace period aligned with typical TCB update intervals, the client will never skip the configured grace period for any TCB number update.
	TcbEvaluationDataNumberUpdateGracePeriod uint32 `protobuf:"varint,12,opt,name=tcb_evaluation_data_number_update_grace_period,json=tcbEvaluationDataNumberUpdateGracePeriod,proto3" json:"tcb_evaluation_data_number_update_grace_period,omitempty"`
	// Next TCB evaluation data number scheduled to be updated
	//
	// Notes:
	// - Must be zero if and only if `next_tcb_evaluation_data_number_update_time` is zero.
	// - When `tcb_evaluation_data_number_update_grace_period` is zero, this field must always be zero.
	// - If this is non-zero, this number must be always greater than the `current_tcb_evaluation_data_number`.
	NextTcbEvaluationDataNumber uint32 `protobuf:"varint,13,opt,name=next_tcb_evaluation_data_number,json=nextTcbEvaluationDataNumber,proto3" json:"next_tcb_evaluation_data_number,omitempty"`
	// Scheduled update time of the next TCB evaluation data number (UNIX time seconds)
	//
	// Notes:
	// - Must be zero if and only if `next_tcb_evaluation_data_number` is zero.
	// - When `tcb_evaluation_data_number_update_grace_period` is zero, this field must always be zero.
	NextTcbEvaluationDataNumberUpdateTime uint64 `protobuf:"varint,14,opt,name=next_tcb_evaluation_data_number_update_time,json=nextTcbEvaluationDataNumberUpdateTime,proto3" json:"next_tcb_evaluation_data_number_update_time,omitempty"`
	// Contains verifier-specific information for zkDCAP proofs.
	//
	// Data format:
	// - First byte (0): zkVM type identifier.
	// - Remaining bytes (1–N): zkVM-specific data.
	//
	// Currently, only RISC Zero zkVM (type=1) is supported, with the following format:
	//
	// | Byte(s) | Description                 |
	// |---------|-----------------------------|
	// | 0       | zkVM type (fixed as 1)      |
	// | 1–31    | Reserved (set as zero)      |
	// | 32–63   | Image ID                    |
	ZkdcapVerifierInfos [][]byte `protobuf:"bytes,15,rep,name=zkdcap_verifier_infos,json=zkdcapVerifierInfos,proto3" json:"zkdcap_verifier_infos,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_69f4c398e914fe8d, []int{4}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

type ConsensusState struct {
	// An identifier that uniquely indicates the ELC state at a specific height
	//
	// Please check the state ID details: <https://docs.lcp.network/protocol/elc#state-id>
	StateId []byte `protobuf:"bytes,1,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`
	// The timestamp of the target chain's block corresponding to the consensus height,
	// expressed in UNIX time (seconds).
	Timestamp uint64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *ConsensusState) Reset()         { *m = ConsensusState{} }
func (m *ConsensusState) String() string { return proto.CompactTextString(m) }
func (*ConsensusState) ProtoMessage()    {}
func (*ConsensusState) Descriptor() ([]byte, []int) {
	return fileDescriptor_69f4c398e914fe8d, []int{5}
}
func (m *ConsensusState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusState.Merge(m, src)
}
func (m *ConsensusState) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusState) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusState.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusState proto.InternalMessageInfo

func init() {
	proto.RegisterType((*UpdateClientMessage)(nil), "ibc.lightclients.lcp.v1.UpdateClientMessage")
	proto.RegisterType((*RegisterEnclaveKeyMessage)(nil), "ibc.lightclients.lcp.v1.RegisterEnclaveKeyMessage")
	proto.RegisterType((*ZKDCAPRegisterEnclaveKeyMessage)(nil), "ibc.lightclients.lcp.v1.ZKDCAPRegisterEnclaveKeyMessage")
	proto.RegisterType((*UpdateOperatorsMessage)(nil), "ibc.lightclients.lcp.v1.UpdateOperatorsMessage")
	proto.RegisterType((*ClientState)(nil), "ibc.lightclients.lcp.v1.ClientState")
	proto.RegisterType((*ConsensusState)(nil), "ibc.lightclients.lcp.v1.ConsensusState")
}

func init() { proto.RegisterFile("ibc/lightclients/lcp/v1/lcp.proto", fileDescriptor_69f4c398e914fe8d) }

var fileDescriptor_69f4c398e914fe8d = []byte{
	// 892 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x72, 0x1b, 0x35,
	0x18, 0xb5, 0x53, 0x27, 0x4d, 0x14, 0x3b, 0x1d, 0xd4, 0x90, 0x3a, 0x09, 0x5d, 0x27, 0xee, 0x74,
	0xc8, 0x0c, 0x13, 0x9b, 0x14, 0x86, 0x0b, 0xee, 0x9a, 0x1f, 0xc0, 0x74, 0x9a, 0x96, 0x8d, 0xe9,
	0x45, 0x6e, 0x84, 0xbc, 0xfb, 0x65, 0xad, 0xc9, 0x5a, 0x5a, 0x24, 0xad, 0x13, 0xe7, 0x1d, 0x98,
	0xe1, 0x1d, 0x78, 0x10, 0x6e, 0x73, 0xd9, 0x4b, 0xae, 0x18, 0x48, 0x5e, 0x80, 0x47, 0x60, 0xf4,
	0xb3, 0xb6, 0x81, 0xc6, 0x1d, 0xae, 0x6c, 0x9d, 0x73, 0x74, 0xe6, 0x93, 0xbe, 0xf3, 0xad, 0xd0,
	0x36, 0xeb, 0x45, 0xed, 0x94, 0x25, 0x7d, 0x1d, 0xa5, 0x0c, 0xb8, 0x56, 0xed, 0x34, 0xca, 0xda,
	0xc3, 0x3d, 0xf3, 0xd3, 0xca, 0xa4, 0xd0, 0x02, 0x3f, 0x62, 0xbd, 0xa8, 0x35, 0x2d, 0x69, 0x19,
	0x6e, 0xb8, 0xb7, 0xb1, 0x9a, 0x88, 0x44, 0x58, 0x4d, 0xdb, 0xfc, 0x73, 0xf2, 0x8d, 0x86, 0x71,
	0x8c, 0x84, 0x84, 0xb6, 0x93, 0x1b, 0x33, 0xf7, 0xcf, 0x09, 0x9a, 0xa7, 0xe8, 0xe1, 0xf7, 0x59,
	0x4c, 0x35, 0x1c, 0x58, 0xf4, 0x25, 0x28, 0x45, 0x13, 0xc0, 0x4f, 0x50, 0x2d, 0x93, 0xe2, 0x72,
	0x44, 0x06, 0x0e, 0xa8, 0x97, 0xb7, 0xca, 0x3b, 0xd5, 0xb0, 0x6a, 0xc1, 0x42, 0x14, 0x20, 0xa4,
	0x58, 0xc2, 0xa9, 0xce, 0x25, 0xa8, 0xfa, 0xdc, 0xd6, 0xbd, 0x9d, 0x6a, 0x38, 0x85, 0x34, 0x7f,
	0x29, 0xa3, 0xf5, 0x10, 0x12, 0xa6, 0x34, 0xc8, 0x23, 0x1e, 0xa5, 0x74, 0x08, 0x2f, 0x60, 0xbc,
	0x7b, 0x0d, 0x2d, 0x48, 0xc8, 0x84, 0xd4, 0xde, 0xdb, 0xaf, 0xf0, 0x47, 0x68, 0x69, 0xec, 0x51,
	0x9f, 0xb3, 0xd4, 0x04, 0xc0, 0xdb, 0xa8, 0x6a, 0x16, 0x8c, 0x27, 0x24, 0x02, 0xa9, 0xeb, 0xf7,
	0xac, 0x60, 0xd9, 0x63, 0x07, 0x20, 0x35, 0xde, 0x45, 0x58, 0x64, 0x20, 0xa9, 0x16, 0x92, 0x4c,
	0x9c, 0x2a, 0x56, 0xf8, 0x41, 0xc1, 0x9c, 0x14, 0x44, 0xf3, 0xd7, 0x32, 0x6a, 0x9c, 0xbe, 0x38,
	0x3c, 0x78, 0xfe, 0xfa, 0xee, 0x5a, 0x37, 0xd1, 0xd2, 0xd5, 0xf9, 0x70, 0x40, 0xf4, 0x28, 0x73,
	0x57, 0x51, 0x0b, 0x17, 0x0d, 0xd0, 0x1d, 0x65, 0x80, 0xbf, 0x44, 0xeb, 0x3f, 0xe6, 0x42, 0x03,
	0x19, 0x82, 0x64, 0x67, 0x2c, 0xa2, 0x9a, 0x09, 0x4e, 0x44, 0xae, 0xb3, 0x5c, 0xfb, 0x03, 0x3c,
	0xb2, 0x82, 0x37, 0x53, 0xfc, 0x2b, 0x4b, 0xe3, 0x55, 0x34, 0x9f, 0x49, 0x21, 0xce, 0xfc, 0x39,
	0xdc, 0xe2, 0xff, 0x9e, 0xe0, 0xa7, 0x39, 0xb4, 0xe6, 0x9a, 0xf8, 0xca, 0x73, 0xaa, 0x28, 0x7c,
	0x15, 0xcd, 0x73, 0xc1, 0x23, 0x57, 0x74, 0x25, 0x74, 0x0b, 0xd3, 0x5d, 0x0e, 0x17, 0xa4, 0x70,
	0x2a, 0x7a, 0x57, 0xe5, 0x70, 0x31, 0x76, 0xc0, 0x1d, 0xb4, 0xfd, 0x0f, 0x11, 0xd1, 0x7d, 0x09,
	0xaa, 0x2f, 0xd2, 0x98, 0xf0, 0x7c, 0xe0, 0x40, 0x5b, 0x76, 0x25, 0x0c, 0xa6, 0x37, 0x76, 0x0b,
	0xd9, 0x71, 0xa1, 0xc2, 0x2f, 0xd1, 0x93, 0xbb, 0xac, 0x62, 0xe0, 0x62, 0xc0, 0xb8, 0x35, 0xab,
	0x58, 0xb3, 0xad, 0x77, 0x9a, 0x1d, 0x4e, 0x74, 0xff, 0xca, 0xdd, 0xfc, 0x7f, 0x72, 0xf7, 0xd7,
	0x02, 0x5a, 0x76, 0x71, 0x3e, 0xd1, 0x54, 0x83, 0x49, 0xd4, 0x40, 0x82, 0x6b, 0xaa, 0x0f, 0xdb,
	0x04, 0xc0, 0x4f, 0xd1, 0xca, 0x39, 0x8c, 0x08, 0x5c, 0x66, 0x4c, 0xda, 0xd6, 0xd8, 0x9e, 0x55,
	0xc2, 0xda, 0x39, 0x8c, 0x8e, 0xc6, 0xa0, 0x89, 0xeb, 0x99, 0x14, 0x57, 0xc0, 0xed, 0x99, 0x17,
	0x43, 0xbf, 0xc2, 0x47, 0xa8, 0x96, 0x52, 0x0d, 0x4a, 0x93, 0x3e, 0x98, 0xb1, 0xb4, 0xa7, 0x58,
	0x7e, 0xb6, 0xd1, 0x32, 0x83, 0x6a, 0x26, 0xaf, 0xe5, 0xe7, 0x6d, 0xb8, 0xd7, 0xfa, 0xc6, 0x2a,
	0xf6, 0x2b, 0xd7, 0xbf, 0x37, 0x4a, 0x61, 0xd5, 0x6d, 0x73, 0x18, 0xfe, 0x1c, 0xad, 0xd1, 0x34,
	0x15, 0x17, 0x10, 0x13, 0x17, 0x26, 0xa5, 0xa9, 0xce, 0x95, 0x3f, 0xdf, 0x52, 0xb8, 0xea, 0xd9,
	0xef, 0x0c, 0x79, 0xe2, 0x39, 0xfc, 0x29, 0x2a, 0x70, 0x42, 0xe3, 0x21, 0x53, 0x42, 0x8e, 0x08,
	0x8b, 0x55, 0x7d, 0xc1, 0xee, 0xc1, 0x9e, 0x7b, 0xee, 0xa9, 0x4e, 0xac, 0xcc, 0x5d, 0x4c, 0xda,
	0x7e, 0xdf, 0x5e, 0xdd, 0x04, 0xc0, 0x1f, 0xa3, 0x07, 0x93, 0x26, 0xb9, 0xe0, 0x2c, 0xda, 0xcb,
	0x58, 0x19, 0xc3, 0xc7, 0x36, 0x41, 0xfb, 0xe8, 0xf1, 0xec, 0x60, 0x2c, 0xd9, 0x6d, 0x9b, 0x62,
	0x46, 0x2a, 0xbe, 0x42, 0x8d, 0xf7, 0x25, 0x02, 0x59, 0x97, 0xc7, 0x62, 0x66, 0x1c, 0xbe, 0x45,
	0xcd, 0x28, 0x97, 0x12, 0xb8, 0x26, 0x3a, 0xea, 0x11, 0x18, 0xd2, 0x34, 0x77, 0x33, 0x18, 0x53,
	0x4d, 0x4d, 0x4d, 0x3d, 0x90, 0xf5, 0x65, 0x3b, 0xb5, 0x81, 0x57, 0x76, 0xa3, 0xde, 0xd1, 0x58,
	0x77, 0x48, 0x35, 0x3d, 0xb6, 0x2a, 0xfc, 0x03, 0x6a, 0xdd, 0xed, 0x41, 0x72, 0x3b, 0x64, 0x24,
	0x91, 0x34, 0x02, 0x92, 0x81, 0x64, 0x22, 0xae, 0x57, 0xad, 0xef, 0x8e, 0x7e, 0xb7, 0xa1, 0x1b,
	0xcb, 0xaf, 0xcd, 0x86, 0xd7, 0x56, 0x8f, 0x0f, 0x51, 0x83, 0xc3, 0xe5, 0xcc, 0x52, 0x6b, 0xd6,
	0x72, 0xd3, 0xc8, 0xee, 0xaa, 0xf3, 0x14, 0x7d, 0xf2, 0x1e, 0x97, 0xa2, 0x58, 0xcd, 0x06, 0x50,
	0x5f, 0xb1, 0xf7, 0xf8, 0x74, 0x86, 0xa3, 0x2b, 0xb4, 0xcb, 0x06, 0x80, 0x9f, 0xa1, 0x0f, 0xaf,
	0xce, 0xe3, 0x88, 0x66, 0xfe, 0x83, 0x06, 0x92, 0x30, 0x7e, 0x26, 0x54, 0xfd, 0x81, 0x8d, 0xcb,
	0x43, 0x47, 0xbe, 0xf1, 0x5c, 0xc7, 0x50, 0xcd, 0x0e, 0x5a, 0x39, 0x10, 0x5c, 0x01, 0x57, 0xb9,
	0x72, 0x43, 0xb7, 0x8e, 0x16, 0x4d, 0x84, 0x81, 0xb0, 0xd8, 0xcf, 0xdc, 0x7d, 0xbb, 0xee, 0xc4,
	0x26, 0x83, 0xa6, 0x2a, 0xa5, 0xe9, 0x20, 0xf3, 0xc3, 0x36, 0x01, 0xf6, 0xbb, 0xd7, 0x7f, 0x06,
	0xa5, 0xeb, 0x9b, 0xa0, 0xfc, 0xf6, 0x26, 0x28, 0xff, 0x71, 0x13, 0x94, 0x7f, 0xbe, 0x0d, 0x4a,
	0x6f, 0x6f, 0x83, 0xd2, 0x6f, 0xb7, 0x41, 0xe9, 0xf4, 0x8b, 0x84, 0xe9, 0x7e, 0xde, 0x6b, 0x45,
	0x62, 0xd0, 0x36, 0xa7, 0x8d, 0xfa, 0x94, 0xf1, 0x94, 0xf6, 0xcc, 0x13, 0xb9, 0x9b, 0x08, 0xf7,
	0x7a, 0xee, 0x4e, 0x3f, 0x9f, 0xe6, 0x9b, 0xad, 0x7a, 0x0b, 0xf6, 0xb9, 0xfb, 0xec, 0xef, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x21, 0xd6, 0x99, 0x59, 0x63, 0x07, 0x00, 0x00,
}

func (m *UpdateClientMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateClientMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateClientMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signatures[iNdEx])
			copy(dAtA[i:], m.Signatures[iNdEx])
			i = encodeVarintLcp(dAtA, i, uint64(len(m.Signatures[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ProxyMessage) > 0 {
		i -= len(m.ProxyMessage)
		copy(dAtA[i:], m.ProxyMessage)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.ProxyMessage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterEnclaveKeyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterEnclaveKeyMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterEnclaveKeyMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperatorSignature) > 0 {
		i -= len(m.OperatorSignature)
		copy(dAtA[i:], m.OperatorSignature)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.OperatorSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SigningCert) > 0 {
		i -= len(m.SigningCert)
		copy(dAtA[i:], m.SigningCert)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.SigningCert)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Report) > 0 {
		i -= len(m.Report)
		copy(dAtA[i:], m.Report)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.Report)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKDCAPRegisterEnclaveKeyMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKDCAPRegisterEnclaveKeyMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKDCAPRegisterEnclaveKeyMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OperatorSignature) > 0 {
		i -= len(m.OperatorSignature)
		copy(dAtA[i:], m.OperatorSignature)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.OperatorSignature)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.QuoteVerificationOutput) > 0 {
		i -= len(m.QuoteVerificationOutput)
		copy(dAtA[i:], m.QuoteVerificationOutput)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.QuoteVerificationOutput)))
		i--
		dAtA[i] = 0x12
	}
	if m.ZkvmType != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.ZkvmType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateOperatorsMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateOperatorsMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateOperatorsMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for iNdEx := len(m.Signatures) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signatures[iNdEx])
			copy(dAtA[i:], m.Signatures[iNdEx])
			i = encodeVarintLcp(dAtA, i, uint64(len(m.Signatures[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.NewOperatorsThresholdDenominator != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.NewOperatorsThresholdDenominator))
		i--
		dAtA[i] = 0x20
	}
	if m.NewOperatorsThresholdNumerator != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.NewOperatorsThresholdNumerator))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NewOperators) > 0 {
		for iNdEx := len(m.NewOperators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NewOperators[iNdEx])
			copy(dAtA[i:], m.NewOperators[iNdEx])
			i = encodeVarintLcp(dAtA, i, uint64(len(m.NewOperators[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Nonce != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ZkdcapVerifierInfos) > 0 {
		for iNdEx := len(m.ZkdcapVerifierInfos) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ZkdcapVerifierInfos[iNdEx])
			copy(dAtA[i:], m.ZkdcapVerifierInfos[iNdEx])
			i = encodeVarintLcp(dAtA, i, uint64(len(m.ZkdcapVerifierInfos[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.NextTcbEvaluationDataNumberUpdateTime != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.NextTcbEvaluationDataNumberUpdateTime))
		i--
		dAtA[i] = 0x70
	}
	if m.NextTcbEvaluationDataNumber != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.NextTcbEvaluationDataNumber))
		i--
		dAtA[i] = 0x68
	}
	if m.TcbEvaluationDataNumberUpdateGracePeriod != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.TcbEvaluationDataNumberUpdateGracePeriod))
		i--
		dAtA[i] = 0x60
	}
	if m.CurrentTcbEvaluationDataNumber != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.CurrentTcbEvaluationDataNumber))
		i--
		dAtA[i] = 0x58
	}
	if m.OperatorsThresholdDenominator != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.OperatorsThresholdDenominator))
		i--
		dAtA[i] = 0x50
	}
	if m.OperatorsThresholdNumerator != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.OperatorsThresholdNumerator))
		i--
		dAtA[i] = 0x48
	}
	if m.OperatorsNonce != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.OperatorsNonce))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Operators) > 0 {
		for iNdEx := len(m.Operators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Operators[iNdEx])
			copy(dAtA[i:], m.Operators[iNdEx])
			i = encodeVarintLcp(dAtA, i, uint64(len(m.Operators[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.AllowedAdvisoryIds) > 0 {
		for iNdEx := len(m.AllowedAdvisoryIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedAdvisoryIds[iNdEx])
			copy(dAtA[i:], m.AllowedAdvisoryIds[iNdEx])
			i = encodeVarintLcp(dAtA, i, uint64(len(m.AllowedAdvisoryIds[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.AllowedQuoteStatuses) > 0 {
		for iNdEx := len(m.AllowedQuoteStatuses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedQuoteStatuses[iNdEx])
			copy(dAtA[i:], m.AllowedQuoteStatuses[iNdEx])
			i = encodeVarintLcp(dAtA, i, uint64(len(m.AllowedQuoteStatuses[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.LatestHeight.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintLcp(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Frozen {
		i--
		if m.Frozen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.KeyExpiration != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.KeyExpiration))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Mrenclave) > 0 {
		i -= len(m.Mrenclave)
		copy(dAtA[i:], m.Mrenclave)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.Mrenclave)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintLcp(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if len(m.StateId) > 0 {
		i -= len(m.StateId)
		copy(dAtA[i:], m.StateId)
		i = encodeVarintLcp(dAtA, i, uint64(len(m.StateId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLcp(dAtA []byte, offset int, v uint64) int {
	offset -= sovLcp(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UpdateClientMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProxyMessage)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for _, b := range m.Signatures {
			l = len(b)
			n += 1 + l + sovLcp(uint64(l))
		}
	}
	return n
}

func (m *RegisterEnclaveKeyMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Report)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	l = len(m.SigningCert)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	l = len(m.OperatorSignature)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	return n
}

func (m *ZKDCAPRegisterEnclaveKeyMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ZkvmType != 0 {
		n += 1 + sovLcp(uint64(m.ZkvmType))
	}
	l = len(m.QuoteVerificationOutput)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	l = len(m.OperatorSignature)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	return n
}

func (m *UpdateOperatorsMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovLcp(uint64(m.Nonce))
	}
	if len(m.NewOperators) > 0 {
		for _, b := range m.NewOperators {
			l = len(b)
			n += 1 + l + sovLcp(uint64(l))
		}
	}
	if m.NewOperatorsThresholdNumerator != 0 {
		n += 1 + sovLcp(uint64(m.NewOperatorsThresholdNumerator))
	}
	if m.NewOperatorsThresholdDenominator != 0 {
		n += 1 + sovLcp(uint64(m.NewOperatorsThresholdDenominator))
	}
	if len(m.Signatures) > 0 {
		for _, b := range m.Signatures {
			l = len(b)
			n += 1 + l + sovLcp(uint64(l))
		}
	}
	return n
}

func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mrenclave)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	if m.KeyExpiration != 0 {
		n += 1 + sovLcp(uint64(m.KeyExpiration))
	}
	if m.Frozen {
		n += 2
	}
	l = m.LatestHeight.Size()
	n += 1 + l + sovLcp(uint64(l))
	if len(m.AllowedQuoteStatuses) > 0 {
		for _, s := range m.AllowedQuoteStatuses {
			l = len(s)
			n += 1 + l + sovLcp(uint64(l))
		}
	}
	if len(m.AllowedAdvisoryIds) > 0 {
		for _, s := range m.AllowedAdvisoryIds {
			l = len(s)
			n += 1 + l + sovLcp(uint64(l))
		}
	}
	if len(m.Operators) > 0 {
		for _, b := range m.Operators {
			l = len(b)
			n += 1 + l + sovLcp(uint64(l))
		}
	}
	if m.OperatorsNonce != 0 {
		n += 1 + sovLcp(uint64(m.OperatorsNonce))
	}
	if m.OperatorsThresholdNumerator != 0 {
		n += 1 + sovLcp(uint64(m.OperatorsThresholdNumerator))
	}
	if m.OperatorsThresholdDenominator != 0 {
		n += 1 + sovLcp(uint64(m.OperatorsThresholdDenominator))
	}
	if m.CurrentTcbEvaluationDataNumber != 0 {
		n += 1 + sovLcp(uint64(m.CurrentTcbEvaluationDataNumber))
	}
	if m.TcbEvaluationDataNumberUpdateGracePeriod != 0 {
		n += 1 + sovLcp(uint64(m.TcbEvaluationDataNumberUpdateGracePeriod))
	}
	if m.NextTcbEvaluationDataNumber != 0 {
		n += 1 + sovLcp(uint64(m.NextTcbEvaluationDataNumber))
	}
	if m.NextTcbEvaluationDataNumberUpdateTime != 0 {
		n += 1 + sovLcp(uint64(m.NextTcbEvaluationDataNumberUpdateTime))
	}
	if len(m.ZkdcapVerifierInfos) > 0 {
		for _, b := range m.ZkdcapVerifierInfos {
			l = len(b)
			n += 1 + l + sovLcp(uint64(l))
		}
	}
	return n
}

func (m *ConsensusState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateId)
	if l > 0 {
		n += 1 + l + sovLcp(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovLcp(uint64(m.Timestamp))
	}
	return n
}

func sovLcp(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLcp(x uint64) (n int) {
	return sovLcp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpdateClientMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateClientMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateClientMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyMessage = append(m.ProxyMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.ProxyMessage == nil {
				m.ProxyMessage = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, make([]byte, postIndex-iNdEx))
			copy(m.Signatures[len(m.Signatures)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterEnclaveKeyMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterEnclaveKeyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterEnclaveKeyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Report", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Report = append(m.Report[:0], dAtA[iNdEx:postIndex]...)
			if m.Report == nil {
				m.Report = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigningCert = append(m.SigningCert[:0], dAtA[iNdEx:postIndex]...)
			if m.SigningCert == nil {
				m.SigningCert = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorSignature = append(m.OperatorSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.OperatorSignature == nil {
				m.OperatorSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKDCAPRegisterEnclaveKeyMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKDCAPRegisterEnclaveKeyMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKDCAPRegisterEnclaveKeyMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZkvmType", wireType)
			}
			m.ZkvmType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZkvmType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteVerificationOutput", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QuoteVerificationOutput = append(m.QuoteVerificationOutput[:0], dAtA[iNdEx:postIndex]...)
			if m.QuoteVerificationOutput == nil {
				m.QuoteVerificationOutput = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof[:0], dAtA[iNdEx:postIndex]...)
			if m.Proof == nil {
				m.Proof = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorSignature = append(m.OperatorSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.OperatorSignature == nil {
				m.OperatorSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateOperatorsMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateOperatorsMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateOperatorsMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewOperators", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewOperators = append(m.NewOperators, make([]byte, postIndex-iNdEx))
			copy(m.NewOperators[len(m.NewOperators)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewOperatorsThresholdNumerator", wireType)
			}
			m.NewOperatorsThresholdNumerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewOperatorsThresholdNumerator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewOperatorsThresholdDenominator", wireType)
			}
			m.NewOperatorsThresholdDenominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewOperatorsThresholdDenominator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signatures = append(m.Signatures, make([]byte, postIndex-iNdEx))
			copy(m.Signatures[len(m.Signatures)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mrenclave", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mrenclave = append(m.Mrenclave[:0], dAtA[iNdEx:postIndex]...)
			if m.Mrenclave == nil {
				m.Mrenclave = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyExpiration", wireType)
			}
			m.KeyExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyExpiration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frozen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Frozen = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LatestHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedQuoteStatuses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedQuoteStatuses = append(m.AllowedQuoteStatuses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedAdvisoryIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedAdvisoryIds = append(m.AllowedAdvisoryIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operators", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operators = append(m.Operators, make([]byte, postIndex-iNdEx))
			copy(m.Operators[len(m.Operators)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorsNonce", wireType)
			}
			m.OperatorsNonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatorsNonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorsThresholdNumerator", wireType)
			}
			m.OperatorsThresholdNumerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatorsThresholdNumerator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorsThresholdDenominator", wireType)
			}
			m.OperatorsThresholdDenominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatorsThresholdDenominator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTcbEvaluationDataNumber", wireType)
			}
			m.CurrentTcbEvaluationDataNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTcbEvaluationDataNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TcbEvaluationDataNumberUpdateGracePeriod", wireType)
			}
			m.TcbEvaluationDataNumberUpdateGracePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TcbEvaluationDataNumberUpdateGracePeriod |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTcbEvaluationDataNumber", wireType)
			}
			m.NextTcbEvaluationDataNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTcbEvaluationDataNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTcbEvaluationDataNumberUpdateTime", wireType)
			}
			m.NextTcbEvaluationDataNumberUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTcbEvaluationDataNumberUpdateTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZkdcapVerifierInfos", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZkdcapVerifierInfos = append(m.ZkdcapVerifierInfos, make([]byte, postIndex-iNdEx))
			copy(m.ZkdcapVerifierInfos[len(m.ZkdcapVerifierInfos)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLcp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLcp
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLcp
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateId = append(m.StateId[:0], dAtA[iNdEx:postIndex]...)
			if m.StateId == nil {
				m.StateId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLcp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLcp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLcp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLcp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLcp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLcp
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLcp
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLcp
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLcp        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLcp          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLcp = fmt.Errorf("proto: unexpected end of group")
)
